# Simulate some random data to test MongoDBs array handling
from random import normalvariate, random
from datetime import datetime
import sys

sigma = 4
mus = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
ns = [10, 20, 30, 40]
#ns = [2, 2, 2, 2]

def randN(mu, n):
    return [normalvariate(mu, sigma) for i in xrange(n)]

def createF(mu):
    return dict(
        f1 = randN(mu, ns[0]),
        f2 = randN(mu, ns[1]),
        f3 = randN(mu, ns[2]),
        f4 = randN(mu, ns[3])
        )

def createT1(mu):
    return dict(
        t1 = createF(mu),
        t2 = createF(mu),
        t3 = createF(mu),
        t4 = createF(mu)
        )

def createT2(mu):
    return dict(
        t1 = createT1(mu),
        t2 = createT1(mu),
        t3 = createT1(mu),
        t4 = createT1(mu)
        )

def createT3(mu):
    return dict(
        t1 = createT2(mu),
        t2 = createT2(mu),
        t3 = createT2(mu),
        t4 = createT2(mu)
        )

def randomDeleteField(d, p):
    """
    Delete a dict field with probability p
    """
    for k in d.keys():
        if random() < p:
            del d[k]

def mergeDicts(a, b):
    if a is None:
        return b
    for k in b.keys():
        if k in a:
            mergeDicts(a[k], b[k])
        else:
            a[k] = b[k]

def simulate(id, mu, delField = 0.0):
    # 1 set of 4 feature groups (sum(ns) features in total)
    d = createF(mu)
    # 4 sets
    t1 = createT1(mu)
    mergeDicts(d, t1)
    # 16 sets
    t2 = createT2(mu)
    t2 = randomDeleteField(t2, delField)
    mergeDicts(d, t2)
    # 64 sets
    #t3 = createT3(mu)
    #mergeDicts(d, t3)

    # The _id property will cause this to replace any existing document
    # otherwise an unique _id is autogenerated by mongodb
    d['_id'] = id
    d['timestamp'] = datetime.utcnow()

    return d

# Just so we can double check the number of features (2100 + id + timestamp)
def flattenDict(d):
    l = []
    #for k in d.keys():
    for v in d.values():
        if isinstance(v, dict):
            l.extend(flattenDict(v))
        elif isinstance(v, list):
            l.extend(v)
        else:
            #elif isinstance(v, datetime):
            l.append(v)
    return l


import pymongo
conn = pymongo.Connection('localhost')
# Database test
db = conn.test
# Collection foo
coll = db.foo

def addSimulated(ids):
    for id in ids:
        sys.stdout.write('%d ' % id)
        sys.stdout.flush()
        d = simulate(id + 1, mus[id % len(mus)])
        # insert(): inserts
        # save(): updates if _id exists, otherwise inserts
        # can handle multiple?
        #coll.save(d)
        coll.save(d, safe=True)
    sys.stdout.write('\n')

    print "%s has %d objects" % (coll.name, coll.count())

# Drop the collection foo
# db.foo.database.drop_collection(db.foo or 'foo')
